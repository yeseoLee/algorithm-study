객체지향

EX) 영화관 티켓 키오스크 구현

- 행동 기준으로 코드를 묶었을 때

티켓 가격 = 10000
티켓 갯수 = 5
손님 보유 돈 = 20000
손님 보유 티켓 = 0

함수 구매확인() {
  만약 손님 보유 돈 >= 티켓가격
         티켓판매();
  아니라면
         거절();  
}

함수 티켓판매() {
       손님 보유 돈 -= 티켓가격
       손님 보유 티켓 += 1
       티캣 개수 -= 1
}

단점 
1. 변경가능한 공유 데이터
2.  데이터 구조를 한번 바꾸면 관련된 모든 코드를 수정

- 객체 기준으로 코드를 묶었을 때


객체 손님{
       돈
       물건수
       판매자

       함수 요청();
       함수 보유돈확인();
       함수 현금지급();
       함수 물건받기();
}

객체 판매자{
       돈
       물건수
       물건가격

       함수 물건판매();
       함수 거절();
}

장점 
1. 변경가능한 공유 데이터가 최소로 줄어듬
2. 구현 부분을 쉽게 바꿀 수 있다
3. 메시지를 실제로 처리하는 객체를 쉽게 바꿀 수 있다


변수 판매자 TIKET_SELLER = "티켓 키오스크"
변수 판매자 POPCORN_SELLER = "팝콘 키오스크"

손님.판매자 = TIKET_SELLER
손님.요청()

손님.판매자 = POPCORN_SELLER
손님.요청()


객체 도형{
    메소드 넓이();
}

객체 원 상속 도형{
       반지름
}

객체 사각형 상속 도형{

}


구현내용: 도형이 주어지면 넒이를 반환하시오

변수 도형 A = 원
변수 도형 B = 사각형

A.넓이();
B.넓이();





키오스크 
- 기능

티켓판매() {
    보유 티켓 확인();
    손님 잔액 확인();
    결제();
}

보유 티켓 확인(){
    if 현재 보유중인 티켓 <= 0{
        티켓 품절();
    }
}

손님 잔액 확인(){
     if 손님 보유 잔액 < 티켓가격 {
        거절("잔액 부족"); 
    }
}

결재(){
    손님 보유 잔액 -= 티켓가격; // (결제)
    손님 티켓 += 1 
    키오스크 티켓 -= 1
}